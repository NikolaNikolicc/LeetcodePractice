# Python Tips for LeetCode Problem Solving

## üìã Table of Contents
1. [Array Optimization Techniques](#array-optimization)
2. [Data Structures](#data-structures)
3. [Algorithm Optimization](#algorithm-optimization)
4. [Built-in Libraries](#built-in-libraries)
5. [Memory Management](#memory-management)
6. [Graph Theory](#graph-theory)
7. [Bit Operations](#bit-operations)
8. [Sorting Techniques](#sorting-techniques)

---

## üöÄ Array Optimization

### 1. Soft Delete Method
**Concept**: Instead of actually deleting elements, move unwanted elements to the end of the array.
**Benefit**: Reduces time complexity from O(n) to O(1) by swapping instead of shifting all elements.

```python
# Instead of: arr.pop(index)  # O(n)
# Use: swap to end
arr[index], arr[-1] = arr[-1], arr[index]  # O(1)
```

---

## üìä Data Structures

### 2. DefaultDict Usage
**Purpose**: Automatically creates default values for missing keys.

```python
from collections import defaultdict

# Creates empty list for missing keys
my_map = defaultdict(list)

# Creates 0 for missing keys
counter = defaultdict(int)
counter["missing_key"] += 1  # Works without KeyError

# ‚ö†Ô∏è Important: Pass callable (int, list, str), not values (1, [], "")
```

### 3. Counter for Element Frequency
**Usage**: Count occurrences of elements efficiently.

```python
from collections import Counter

nums = [1, 2, 2, 3, 3, 3]
count = Counter(nums)  # {1: 1, 2: 2, 3: 3}
```

### 4. Deque for Queue Operations
**Note**: It's `deque`, not `dequeue`

```python
from collections import deque

q = deque()
q.append(value)      # Add to right
q.appendleft(value)  # Add to left
q.pop()              # Remove from right
q.popleft()          # Remove from left
```

### 5. Heap with Custom Comparison
**Problem**: Using custom objects in heaps

```python
import heapq

class NodeWrapper:
    def __init__(self, node):
        self.node = node
    
    # Enables heapq module to compare elements
    def __lt__(self, other):
        return self.node.val < other.node.val

# Usage
heap = []
heapq.heappush(heap, NodeWrapper(node))
```

**Heap Operations:**
```python
import heapq

# Convert list to heap
heapq.heapify(arr)

# Push and pop
heapq.heappush(heap, value)
min_val = heapq.heappop(heap)

# Get n largest/smallest
largest = heapq.nlargest(n, arr)
smallest = heapq.nsmallest(n, arr)

# üí° Tip: For lists in heap, comparison uses 0th element
heap = [(priority, data), ...]
```

---

## ‚ö° Algorithm Optimization

### 6. Memoization for Recursion
**Purpose**: Cache results to avoid recalculation
**Benefit**: Reduces time complexity from O(2^n) to O(n)

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Alternative: Manual memoization
memo = {}
def fib_memo(n):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1) + fib_memo(n-2)
    return memo[n]
```

### 7. Dynamic Programming Approaches
- **Top-down**: Memoization (recursive with caching)
- **Bottom-up**: Iterative approach, often more space-efficient

### 8. Sorting Stability
**Important**: Algorithms that swap non-adjacent elements are usually **not stable**
- Stable: Merge Sort, Bubble Sort, Insertion Sort
- Unstable: Quick Sort, Heap Sort, Selection Sort

---

## üìö Built-in Libraries

### 9. Math Library
**Note**: `math` library is built-in, no import needed in some environments

```python
import math  # Explicit import recommended

# For integer division with ceiling
a, b = 8, 5
result = math.ceil(a / b)  # Use a/b, not float(a)/b (Python 3 default)

# Common functions
math.floor(x)
math.ceil(x)
math.sqrt(x)
math.log(x)
math.pow(x, y)
```

---

## üíæ Memory Management

### 10. Array Passing (Reference vs Copy)
**Important**: Arrays are passed by reference, modifying the original

```python
def modify_array(arr):
    arr[0] = 999  # Modifies original array

# To pass a copy:
modify_array(arr[:])     # Slice copy
modify_array(arr.copy()) # Explicit copy
modify_array(list(arr))  # List conversion copy
```

### 11. Space Complexity Notes
- **Tree DFS**: Space complexity = O(height of tree)
- **BFS**: Space complexity = O(width of tree)

---

## üåê Graph Theory

### 12. Graph vs Tree Terminology
| Tree | Graph |
|------|-------|
| Node | Vertex |
| Edge/Pointer | Edge |

### 13. Hash Table Implementation Methods
- **Open Addressing**: Linear probing, quadratic probing
- **Chaining**: Using linked lists for collision resolution

### 14. Graph Representation
- **Adjacency Matrix**: O(V¬≤) space, O(1) edge lookup
- **Adjacency List**: O(V + E) space, O(degree) edge lookup
- **Recommendation**: Use adjacency list (fewer edge cases)

---

## üî¢ Bit Operations

### 15. Bitwise Operators
```python
# Basic operations
a & b   # AND
a | b   # OR  
a ^ b   # XOR (exclusive or)
~a      # NOT (bitwise complement)
a << n  # Left shift (multiply by 2^n)
a >> n  # Right shift (divide by 2^n)

# XOR truth table
# 1 ^ 0 = 1, 0 ^ 1 = 1, 1 ^ 1 = 0, 0 ^ 0 = 0

# Common bit tricks
x & 1           # Check if odd
x & (x - 1)     # Remove rightmost set bit
x & -x          # Get rightmost set bit
```

---

## üîÑ Sorting Techniques

### 16. Indirect Sorting (Sort by Custom Key)
**Use case**: Sort indices based on array values

```python
capital = [17, 12, 13]
n = len(capital)
indices = list(range(n))  # [0, 1, 2]

# Sort indices by corresponding values
indices.sort(key=lambda i: capital[i])
print(indices)  # [1, 2, 0] (sorted by values: 12, 13, 17)

# Now indices[0] points to smallest value in capital
```

---

## üí° Quick Reference

### Essential Imports
```python
from collections import defaultdict, deque, Counter
from functools import lru_cache
import heapq
import math
```

### Time Complexity Reminders
- Hash operations: O(1) average
- Heap operations: O(log n)
- Sorting: O(n log n)
- Tree traversal: O(n)
- Memoized recursion: Often O(n) instead of O(2^n)

---

*Happy coding! üêç*